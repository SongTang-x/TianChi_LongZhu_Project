# 学习笔记  （python）

Day 1

按位取反操作结论：~n = -(n+1)  

is, is not 对比的是两个变量的内存地址，==, != 对比的是两个变量的值  

比较的两个变量，指向的都是地址不可变的类型（str等），那么is，is not 和 ==，！= 是完全等价的  

对比的两个变量，指向的是地址可变的类型（list，dict，tuple等），则两者是有区别的  

Python 变量名是大小写敏感的  

当把布尔型变量用在数字运算中，用 1 和 0 代表 True 和 False  

type() 不会认为子类是一种父类类型，不考虑继承关系  

isinstance() 会认为子类是一种父类类型，考虑继承关系  

Python中bin一个负数（十进制表示），输出的是它的原码的二进制表示加上个负号

Day2

使用多个except代码块时，必须坚持对其规范排序，要从最具针对性的异常到最通用的异常

一个 except 子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组

列表是有序集合，没有固定大小，能够保存任意数量任意类型的 Python 对象

由于list的元素可以是任何对象，因此列表中所保存的是对象的指针。即使保存一个简单的[1,2,3]，也有3个指针和3个整数对象

x = [a] * 4操作中，只是创建4个指向list的引用，所以一旦a改变，x中4个a也会随之改变

Day 3

remove 和 pop 都可以删除元素，前者是指定具体要删除的元素，后者是指定一个索引

如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还能继续使用它，就使用方法pop()

把 step 设为 -1，相当于将列表反向排列,切片的第三位是step

list1 = [[123, 456], [789, 213]]
list2 = list1   深复制
list3 = list1[:]  外列表是浅复制，内列表是深复制

「等号 ==」，只有成员、成员位置都相同时才返回True

reverse = True 降序， reverse = False 升序（默认）

方法里面可以嵌套函数

元组与列表类似，也用整数来对它进行索引 (indexing) 和切片 (slicing)

创建元组可以用小括号 ()，也可以什么都不用，元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用

元组有不可更改 (immutable) 的性质，因此不能直接给元组的元素赋值，但是只要元组中的元素可更改 (mutable)，那么我们可以直接更改其元素

元组大小和内容都不可更改，因此只有 count 和 index 两种方法

解压（unpack）一维元组（有几个元素左边括号定义几个变量）
解压二维元组（按照元组里的元组结构来定义变量）
如果你只想要元组其中几个元素，用通配符「*」
如果你根本不在乎 rest 变量，那么就用通配符「*」加上下划线「_」

Day 4

三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符

最后一个元素的位置编号是 -1

swapcase() 将字符串中大写转换为小写，小写转换为大写

endswith(suffix, beg=0, end=len(string)) 检查字符串是否以指定子字符串 suffix 结束，如果是，返回 True，否则返回 False。如果 beg 和 end 指定值，则在指定范围内检查

startswith(substr, beg=0,end=len(string)) 检查字符串是否以指定子字符串 substr 开头，如果是，返回 True，否则返回 False。如果 beg 和 end 指定值，则在指定范围内检查

rfind(str, beg=0,end=len(string)) 类似于 find() 函数，不过是从右边开始查找

partition(sub) 找到子字符串sub，把字符串分为一个三元组(pre_sub,sub,fol_sub)，如果字符串中不包含sub则返回('原字符串','',''),rpartition(sub)类似于partition()方法，不过是从右边开始查找

先maketrans再translate

'{0:.2f}{1}'.format(27.658, 'GB')  # 保留小数点后两位，位置参数要在关键字参数之前

字典以"关键字"为索引，关键字可以是任意不可变类型，通常用字符串或数值

字典是 Python 唯一的一个 映射类型，字符串、元组、列表属于序列类型

用 hash(X)，只要不报错，证明 X 可被哈希，即不可变，反过来不可被哈希，即可变

用 id(X) 函数，对 X 进行某种操作，比较操作前后的 id，如果不一样，则 X 不可变，如果一样，则 X 可变

多次对一个key放入 value，后面的值会把前面的值冲掉

dict.popitem()随机返回并删除字典中的一对键和值

集合的两个特点：无序 (unordered) 和唯一 (unique)

不可以为集合创建索引或执行切片(slice)操作，也没有键(keys)可用来获取集合中元素的值，但是可以判断一个元素是否在集合中

set.remove(item) 用于移除集合中的指定元素。如果元素不存在，则会发生错误，而 discard() 方法不会

set.pop() 用于随机移除一个元素

set.intersection(set1, set2) 、set1 & set2、set.intersection_update(set1, set2)返回两个集合的交集

set.union(set1, set2)、set1 | set2返回两个集合的并集

set.difference(set)、set1 - set2 、set.difference_update(set) 返回集合的差集

set.symmetric_difference(set)、set1 ^ set2 返回集合的异或、set.symmetric_difference_update(set)返回集合的异或

set.issubset(set)、set1 <= set2判断集合是不是被其他集合包含

frozenset([iterable]) 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素

Day 5

Python 把函数也当成对象，参数是函数、返回值是函数

*args - 可变参数，可以是从零个到任意个，自动组装成元组，加了星号（*）的变量名会存放所有未命名的变量参数

**kw - 关键字参数，可以是从零个到任意个，自动组装成字典

*, nkw - 命名关键字参数，用户想要输入的关键字参数，定义方式是在nkw 前面加个分隔符 *，使用命名关键字参数时，要特别注意不能缺少参数名

定义命名关键字参数不要忘了写分隔符 *，否则定义的是位置参数

内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字

如果在一个内部函数里对外层非全局作用域的变量进行引用，那么内部函数就被认为是闭包，通过闭包可以访问外层非全局作用域的变量，这个作用域称为闭包作用域

如果要修改闭包作用域中的变量则需要 nonlocal 关键字

如果一个函数在内部调用自身本身，这个函数就是递归函数

Day 6

匿名函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数

filter(function, iterable) 过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 list() 来转换

map(function, *iterables) 根据提供的函数对指定序列做映射,返回的也是迭代器

Python 的 self 相当于 C++ 的 this 指针

类的方法与普通的函数只有一个特别的区别 —— 它们必须有一个额外的第一个参数名称（对应于该实例，即该对象本身），按照惯例它的名称是 self。在调用方法时，我们无需明确提供与参数 self 相对应的参数。

在 Python 中定义私有变量只需要在变量名或函数名前加上“__”两个下划线，那么这个函数或变量就会为私有的了

如果子类中定义与父类同名的方法或属性，则会自动覆盖父类对应的方法或属性，解决该问题可用以下两种方式：调用未绑定的父类方法、使用super函数super().__init__()

属性与方法名相同，属性会覆盖方法

Python 严格要求方法需要有实例才能被调用，这种限制其实就是 Python 所谓的绑定概念。

一个类被认为是其自身的子类

isinstance(object, classinfo) 方法用于判断一个对象是否是一个已知的类型，类似type()、如果第一个参数不是对象，则永远返回False。如果第二个参数不是类或者由类对象组成的元组，会抛出一个TypeError异常。

hasattr(object, name)用于判断对象是否包含对应的属性

getattr(object, name[, default])用于返回一个对象属性值

setattr(object, name, value)对应函数 getattr()，用于设置属性值，该属性不一定是存在的

delattr(object, name)用于删除属性

魔法方法总是被双下划线包围，例如__init__

魔法方法的第一个参数应为cls（类方法） 或者self（实例方法），在调用__init__初始化前，先调用__new__，执行了__new__，并不一定会进入__init__，只有__new__返回了，当前类cls的实例，当前类的__init__才会进入，若__new__没有正确返回当前类cls的实例，那__init__是不会被调用的，即使是父类的实例也不行，将没有__init__被调用

__new__方法主要是当你继承一些不可变的 class 时（比如int, str, tuple）， 提供给你一个自定义这些类的实例化过程的途径

__del__(self) 析构器，当一个对象将要被系统回收之时调用的方法

repr是str的备胎，__str__(self) 的返回结果可读性强，__repr__(self) 的返回结果应更准确，__repr__ 存在的目的在于调试

在 Python 中，协议更像是一种指南

迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。
迭代器是一个可以记住遍历的位置的对象。
迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。
迭代器只能往前不会后退。
字符串，列表或元组对象都可用于创建迭代器
iter(object) 函数用来生成迭代器。
next(iterator[, default]) 返回迭代器的下一个项目

在 Python 中，使用了 yield 的函数被称为生成器（generator）。
跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。
在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。
调用一个生成器函数，返回的是一个迭代器对象。



